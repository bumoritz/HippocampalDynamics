function [nem,nemd] = nemPrepareModeling(this_nf_binned,these_events_binned,this_task,info,p)

%% Preparations

numTrials = length(this_task.type);
numBins = size(this_nf_binned,2);


%% Splitting into test set and training set folds
% OLD: test set is assigned 0, training set folds are assigned 1:10
% 500 trials -> 400 into training, 10 folds of 40 trials (5 blocks of 8 trials)
% 800 trials -> 640 into training, 10 folds of 64 trials (8 blocks of 8 trials)
% NEW: test set is assigned 0, training set folds are assigned 1:5
% 500 trials -> 400 into training, 5 folds of 80 trials (5 blocks of 16 trials)
% 800 trials -> 640 into training, 5 folds of 128 trials (8 blocks of 16 trials)

if mod(p.nem.testSet*info.task.trialsPerBlock,1)~=0
    warning('Selected fraction of trials for testing set does not work for our number of trials per block')
end
if mod((1-p.nem.testSet)*numTrials/p.nem.cvFolds,1)~=0
    warning('Selected fraction of trials for training set does not work together with selected number of folds')
end

% select trials for test set
nem.setsByTrials = nan(numTrials,1);
for i=1:numTrials/info.task.trialsPerBlock
    if p.nem.testSet==0.2 && info.task.trialsPerBlock==20
        temp = this_task.type((i-1)*info.task.trialsPerBlock+1:i*info.task.trialsPerBlock);
        for j=1:length(unique(temp))
            nem.setsByTrials(randsample(find(temp==j),1)+(i-1)*info.task.trialsPerBlock)=0;
        end
    else
    	warning('Not implemented')
    end
end

% select trials for training set and assign crossvalidation fold
temp = nonzeros(find(nem.setsByTrials));
for i=1:length(temp)/p.nem.cvFolds
    temp2 = temp((i-1)*p.nem.cvFolds+1:i*p.nem.cvFolds);
    nem.setsByTrials(temp2) = randperm(p.nem.cvFolds);
end

% get bins for selected sets
temp = find(these_events_binned.sync);
nem.setsByBins = nan(1,numBins);
for i=1:numTrials
    if i==1
        nem.setsByBins(1:temp(i+1)-length(p.general.bins_pre)) = nem.setsByTrials(i);
    elseif i==numTrials
        nem.setsByBins(temp(i)-length(p.general.bins_pre)+1:end) = nem.setsByTrials(i);
    else
        nem.setsByBins(temp(i)-length(p.general.bins_pre)+1:temp(i+1)-length(p.general.bins_pre)) = nem.setsByTrials(i);
    end
end


%% Build design matrix
% binSize_s = p.general.binSize/info.scope.frameRate; 5 bins = 1 s

% predictorGroups (from 202210) - incl MOT, excl DLC
nem.predictorGroups.labels = {'A','X','B','Y',...
    'R','L',...
    'v','a','m'};
nem.predictorGroups.names = {'odourA','odourX','odourB','odourY',...
    'reward','lick',...
    'velocity','acceleration','motion'};
nem.predictorGroups.cols = {p.col.A,p.col.X,p.col.B,p.col.Y,...
    p.col.reward,p.col.lick,...
    p.col.velocity,p.col.acceleration,p.col.motion};
nem.predictorGroups.numPredictorsRaw = [25,25,25,25,...
    25,25,...
    1,1,1];
nem.predictorGroups.lead = [0,0,0,0,...
    10,10,...
    0,0,0];
nem.predictorGroups.supGroup = [1,1,2,2,...
    3,3,...
    3,3,3];
nem.predictorGroups.supGroupLabels = {'1^{st} odour','2^{nd} odour','Other'};
nem.predictorGroups.numSupGroups = length(unique(nem.predictorGroups.supGroup));
nem.numPredictorGroups = length(nem.predictorGroups.names);

% predictors
n=0;
nem.predictorGroups.numPredictors = nan(1,nem.numPredictorGroups);
nem.predictors.Xdsgn = [];
for i=1:nem.numPredictorGroups
    these_event_values = these_events_binned.(nem.predictorGroups.names{i});
    if p.nem.predictorStd~=0
        these_event_values = smoothdata(these_event_values,1,'gaussian',p.nem.predictorStd*5);
    end
    these_event_values = nanzscore(these_event_values,[],1);
    these_event_values(isnan(these_event_values))=0;
    nem.predictorGroups.Xdsgn{i} = zeros(length(these_event_values),nem.predictorGroups.numPredictorsRaw(i));
    for j=1:nem.predictorGroups.numPredictorsRaw(i)
        if j-nem.predictorGroups.lead(i)==1 % instantaneous predictor
            nem.predictorGroups.Xdsgn{i}(:,j) = these_event_values;
        elseif j-nem.predictorGroups.lead(i)<1 % leading predictor
            nem.predictorGroups.Xdsgn{i}(1:end+(j-nem.predictorGroups.lead(i)-1),j) = these_event_values(-(j-nem.predictorGroups.lead(i)-2):end);
        elseif j-nem.predictorGroups.lead(i)>1 % lagging predictor
            nem.predictorGroups.Xdsgn{i}(j-nem.predictorGroups.lead(i):end,j) = these_event_values(1:end-(j-nem.predictorGroups.lead(i)-1));
        end
    end
    if p.nem.predictorEveryXBins~=1
        if size(nem.predictorGroups.Xdsgn{i},2) > 1
            nem.predictorGroups.Xdsgn{i} = nem.predictorGroups.Xdsgn{i}(:,ceil(p.nem.predictorEveryXBins/2):p.nem.predictorEveryXBins:end);
        else
            nem.predictorGroups.Xdsgn{i} = nem.predictorGroups.Xdsgn{i}(:,1);
        end
    end
    nem.predictors.Xdsgn = [nem.predictors.Xdsgn,nem.predictorGroups.Xdsgn{i}];
    nem.predictorGroups.numPredictors(i) = size(nem.predictorGroups.Xdsgn{i},2);
    nem.predictorGroups.idcs{i} = n+1:n+size(nem.predictorGroups.Xdsgn{i},2);
    n = n+size(nem.predictorGroups.Xdsgn{i},2);
end
nem.numPredictors = size(nem.predictors.Xdsgn,2);

% predictor colours
nem.predictors.cols = [];
for i=1:nem.numPredictorGroups
    for j=1:nem.predictorGroups.numPredictors(i)
        nem.predictors.cols = [nem.predictors.cols; nem.predictorGroups.cols{i}];
    end
end

% predictorCorr
nem.predictors.predictorCorr = corr(nem.predictors.Xdsgn,'Type','Pearson','Rows','Complete');


%% Assign test groups

% nem.testGroup.label = {'1^{st}','A','X','sens','temp','A_{sens}','A_{temp}','X_{sens}','X_{temp}',...
%     '2^{nd}','B','Y','int','A_{int}','X_{int}',...
%     'R+L','R','L','run','v','a'};
% nem.testGroup.cols = {p.col.odour,p.col.A,p.col.X,p.col.odour,p.col.odour,p.col.A,p.col.A,p.col.X,p.col.X,...
%     p.col.odour,p.col.B,p.col.Y,p.col.odour,p.col.A,p.col.X,...
%     mean([p.col.reward;p.col.lick]),p.col.reward,p.col.lick,mean([p.col.velocity;p.col.acceleration]),p.col.velocity,p.col.acceleration};
% nem.testGroup.group = {[1:4],[1:2],[3:4],[1,3],[2,4],[1],[2],[3],[4],...
%     [5:8],[5,7:8],[6:8],[7:8],[7],[8],...
%     [9:10],[9],[10],[11:12],[11],[12]};
% nem.testGroup.idcs = {}; %{[6:10,16:20,21:25],[6:10,16:20]};
% nem.testGroup.supGroup = [1,1,1,1,1,1,1,1,1,...
%     2,2,2,2,2,2,...
%     3,3,3,3,3,3];
% nem.numTestGroups = length(nem.testGroup.label);

nem.testGroup.label = {'odour','1^{st}','2^{nd}',...
    'A','X','B','Y',...
    'R+L','R','L','run+mot','run','mot'};
nem.testGroup.cols = {p.col.odour,p.col.odour,p.col.odour,...
    p.col.A,p.col.X,p.col.B,p.col.Y,...
    mean([p.col.reward;p.col.lick]),p.col.reward,p.col.lick,mean([mean([p.col.velocity;p.col.acceleration]);p.col.motion]),mean([p.col.velocity;p.col.acceleration]),p.col.motion};
nem.testGroup.group = {[1:4],[1:2],[3:4],...
    [1],[2],[3],[4],...
    [5:6],[5],[6],[7:9],[7:8],[9]};
nem.testGroup.idcs = {}; %{[6:10,16:20,21:25],[6:10,16:20]};
nem.testGroup.supGroup = [0,1,2,...
    1,1,2,2,...
    3,3,3,3,3,3];
nem.numTestGroups = length(nem.testGroup.label);


%% Prepare nemd

nemd.data = this_nf_binned';


end


%% DISCARDED PREDICTOR SETUPS

% --- DEFAULT UNSMOOTHED ---
% nem.predictorGroups.labels = {'A','X','B','Y',...
%     'R','L',...
%     'v','a'};
% nem.predictorGroups.names = {'odourA','odourX','odourB','odourY',...
%     'reward','lick',...
%     'velocity','acceleration'};
% nem.predictorGroups.cols = {p.col.A,p.col.X,p.col.B,p.col.Y...
%     p.col.reward,p.col.lick,...
%     p.col.velocity,p.col.acceleration};
% nem.predictorGroups.numPredictors = [53,53,27,27,...
%     17,17,...
%     1,1];
% nem.predictorGroups.lead = [2,2,2,2,...
%     2,2,...
%     0,0];
% nem.numPredictorGroups = length(nem.predictorGroups.names);

% --- OLD DEFAULT SMOOTHED ---
% nem.predictorGroups.labels = {'A','X','B','Y',...
%     'R','L',...
%     'v','a'};
% nem.predictorGroups.names = {'odourA','odourX','odourB','odourY',...
%     'reward','lick',...
%     'velocity','acceleration'};
% nem.predictorGroups.cols = {p.col.A,p.col.X,p.col.B,p.col.Y...
%     p.col.reward,p.col.lick,...
%     p.col.velocity,p.col.acceleration};
% nem.predictorGroups.numPredictorsRaw = [50,50,25,25,...
%     15,15,...
%     1,1];
% nem.predictorGroups.lead = [0,0,0,0,...
%     0,0,...
%     0,0];
% nem.numPredictorGroups = length(nem.predictorGroups.names);

% predictorGroups (from 202208) - overcomplete (incl DLC)
% nem.predictorGroups.labels = {'A','X','B','Y',...
%     'R','L','s','p'...
%     'v','a','m'};
% nem.predictorGroups.names = {'odourA','odourX','odourB','odourY',...
%     'reward','lick','nose','pupil'...
%     'velocity','acceleration','motion'};
% nem.predictorGroups.cols = {p.col.A,p.col.X,p.col.B,p.col.Y,...
%     p.col.reward,p.col.lick,p.col.darkGray,p.col.darkGray...
%     p.col.velocity,p.col.acceleration,p.col.darkGray};
% nem.predictorGroups.numPredictorsRaw = [25,25,25,25,...
%     25,25,1,1,...
%     1,1,1];
% nem.predictorGroups.lead = [0,0,0,0,...
%     10,10,0,0,...
%     0,0,0];
% nem.predictorGroups.supGroup = [1,1,2,2,...
%     3,3,3,3,...
%     3,3,3];
% nem.predictorGroups.supGroupLabels = {'1^{st} odour','2^{nd} odour','Other'};
% nem.predictorGroups.numSupGroups = length(unique(nem.predictorGroups.supGroup));
% nem.numPredictorGroups = length(nem.predictorGroups.names);

% predictorGroups (at 20220725)
% nem.predictorGroups.labels = {'A_{early}','A_{late}','X_{early}','X_{late}',...
%     'B_{early}','B_{late}','Y_{early}','Y_{late}',...
%     'R','L',...
%     'v','a'};
% nem.predictorGroups.names = {'odourA','odourA','odourX','odourX',...
%     'odourB','odourB','odourY','odourY',...
%     'reward','lick',...
%     'velocity','acceleration'};
% nem.predictorGroups.cols = {p.col.A,p.col.A,p.col.X,p.col.X,...
%     p.col.B,p.col.B,p.col.Y,p.col.Y,...
%     p.col.reward,p.col.lick,...
%     p.col.velocity,p.col.acceleration};
% nem.predictorGroups.numPredictorsRaw = [10,15,10,15,...
%     10,15,10,15,...
%     15,15,...
%     1,1];
% nem.predictorGroups.lead = [0,-10,0,-10,...
%     0,-10,0,-10,...
%     0,0,...
%     0,0];
% nem.predictorGroups.supGroup = [1,1,1,1,...
%     2,2,2,2,...
%     3,3,...
%     3,3];
% nem.predictorGroups.supGroupLabels = {'1^{st} odour','2^{nd} odour','Other'};
% nem.predictorGroups.numSupGroups = length(unique(nem.predictorGroups.supGroup));
% nem.numPredictorGroups = length(nem.predictorGroups.names);

% % predictorGroups (until 20220725)
% nem.predictorGroups.labels = {'A_{sens}','A_{temp}','X_{sens}','X_{temp}',...
%     'B','Y','A_{int}','X_{int}',...
%     'R','L',...
%     'v','a'};
% nem.predictorGroups.names = {'odourA','odourA','odourX','odourX',...
%     'odourB','odourY','odourPostA','odourPostX',...
%     'reward','lick',...
%     'velocity','acceleration'};
% nem.predictorGroups.cols = {p.col.A,p.col.A,p.col.X,p.col.X,...
%     p.col.B,p.col.Y,p.col.A,p.col.X,...
%     p.col.reward,p.col.lick,...
%     p.col.velocity,p.col.acceleration};
% nem.predictorGroups.numPredictorsRaw = [10,15,10,15,...
%     25,25,25,25,...
%     15,15,...
%     1,1];
% nem.predictorGroups.lead = [0,-10,0,-10,...
%     0,0,0,0,...
%     0,0,...
%     0,0];
% nem.predictorGroups.supGroup = [1,1,1,1,...
%     2,2,2,2,...
%     3,3,...
%     3,3];
% nem.predictorGroups.supGroupLabels = {'Response to 1^{st} odour','Response to 2^{nd} odour','Other'};
% nem.predictorGroups.numSupGroups = length(unique(nem.predictorGroups.supGroup));
% nem.numPredictorGroups = length(nem.predictorGroups.names);
